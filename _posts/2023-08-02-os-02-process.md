---
title: (OS - 2) OS에서의 프로세스
description: 프로세스(Process), 스레드(Thread)에 대해서
author: seungki1011
date: 2023-06-29 12:30:00 +0900
categories: [1. 컴퓨터 공학(CS), 운영체제(OS)]
tags: [os, process, thread]
math: true
mermaid: true
---

---

## 1. 프로세스(Process)

### 프로세스 소개

프로세스(Process)는 컴퓨터에서 **실행 중인 프로그램**을 의미한다. 프로세스는 **프로그램 코드와 그에 관련된 자원(예: 메모리, CPU 점유, 입출력 등)을 포함하여 CPU에서 실행될 수 있는 상태를 나타낸다**. 프로세스는 운영 체제에서 프로그램을 실행하는 기본 단위이며, 운영체제는 프로세스 단위로 다양한 작업을 수행하는 데 필요한 자원과 상태를 관리한다.

쉽게 말해서 메모리 위에서 실행 중인 프로그램을 나타내는 하나의 작업 단위를 프로세스라고 생각하면 된다.

<br>

> **프로그램 그 자체는 프로세스가 아니다!**
>
> 프로그램 자체는 명령어의 집합일 뿐이다. 반면에 프로세스는 해당 프로그램을 실행하여, 다음으로 실행할 명령을 알려주는 프로그램 카운터(PC)와 사용하는 자원 모두가 관련되어 있다.
>
> 예를 들면, 게임을 실행을 위해 아이콘을 더블 클릭하기 전 까지는 명령어의 집합으로 존재할 뿐이다. 비로소 실행을 시켜야지만 자원을 할당받고 상태를 관리 받을 수 있는 프로세스가 되는 것이다.
{: .prompt-warning }

<br>

**사용자 영역에서 저장**되는 **프로세스의 메모리 공간(주소 공간)**은 다음과 같이 구성된다.

<br>

![process-memory](../post_images/2023-08-02-os-02-process/process-memory.png)_process memory_

* **텍스트 영역(Text Section)**
  * 실행 가능한 코드가 저장되는 공간
  * 일반적으로 읽기 전용이다
* **데이터 영역(Data Section)**
  * 초기화 된 전역 변수(global variable)와 정적 변수(static variable)를 저장하는 공간
  * BSS 영역이라고 해서, 초기화 되지 않은 전역 변수와 정적 변수를 모아 놓는 영역이 있다
  * 프로그램 시작 시 할당되고 종료 시 해제된다
* **힙 영역(Heap Section)**
  * 런타임(runtime) 도중 동적으로 할당된 메모리 블록이 저장된다
* **스택 영역(Stack Section)**
  * 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 주소 등이 저장된다
  * 스택은 함수 호출시 스택 프레임(stack frame)이 생성되고, 종료시 스택 프레임이 제거되는 방식으로 관리된다

<br>

> **정적 변수(static variable)**
>
>  함수 내부 또는 외부(파일 내)에서 선언되며, 프로그램의 전체 실행 시간 동안 메모리에 존재하는 변수.
{: .prompt-info }

<br>

---

### 프로세스 상태(Process State)

프로세스는 실행 중에 여러 가지 상태를 가지며, 운영 체제는 이러한 상태를 관리하여 프로세스가 올바르게 실행될 수 있도록 한다.

<br>

![process-state](../post_images/2023-08-02-os-02-process/process-state.png)_process state_

프로세스들은 여러 상태를 전이하며 실행된다.(위 그림 참고)

다음은 각 프로세스 상태에 대한 설명이다.

* **new(새로운 상태)**
  * **프로세스가 생성되고 있는 상태**
  * 아직 실행 준비가 되지 않았으며, 운영 체제는 프로세스의 초기화 작업을 수행
  * 메모리 할당, PCB 생성 등의 작업이 이루어진다
* **ready(준비 상태)**
  * **프로세스가 실행 준비가 완료된 상태**
  * 프로세스는 실행될 준비가 되어 있지만, 현재 CPU를 사용할 수 없는 상태이다
  * 준비 상태 큐에 위치하며, CPU 할당을 기다린다
* **running(실행 상태)**
  * **프로세스가 현재 CPU를 사용하여 실행되고 있는 상태**
  * 하나의 CPU 코어는 동시에 하나의 프로세스만 실행할 수 있기 때문에, 실행 상태는 오직 하나의 프로세스만 가질 수 있다
* **waiting, blocked(대기 상태)**
  * **프로세스가 실행을 중단하고 특정 이벤트(예: I/O 작업, 자원 할당 등)를 기다리고 있는 상태**
  * 대기 상태 큐에서 관리된다
* **terminated(종료 상태)**
  * **프로세스가 실행을 완료하거나 강제로 종료된 상태**
  * 운영 체제는 프로세스의 자원을 회수하고, 프로세스 제어 블록(PCB)을 제거한다

<br>

> 일부 운영 체제에서는 프로세스 관리를 더 효율적으로 하기 위해 추가적인 상태를 정의하기도 한다.
>
> 예시) Suspended-Blocked, Suspended-Ready, 등 ...
{: .prompt-info }


<br>

---

### 프로세스 제어 블록(PCB, Process Control Block)

시분할(time-sharing) 운영 체제에서는 **프로세스들은 번갈아가며 한정된 시간 만큼만 CPU를 이용**해야 한다. 

각 프로세스 마다 CPU를 사용할 수 있는 일정한 시간을 할당하고, 프로세스가 할당된 시간을 다 사용하면 타이머 인터럽트(timer interrupt)가 발생해서 다음 프로세스로 전환 된다.

<br>

빠르게 번갈아가면서 수행되는 **프로세스들을 효율적으로 관리하기 위해서 사용하는 자료구조**를 **PCB(Process Control Block)**라고 한다. **커널에서는 프로세스를 다음과 같이 PCB 형태로 관리**한다고 보면 된다.

<br>

![pcb](../post_images/2023-08-02-os-02-process/pcb.png)_PCB_

* **프로세스 식별자(PID, Process number, Process identifier)**
  * 각 프로세스를 고유하게 식별하는 값
  * PID를 통해 운영 체제는 프로세스를 구분하고 관리한다

* **프로세스 상태(Process state)**
  * 현재 프로세스의 상태

* **프로그램 카운터(Program Counter, PC)**
  * 프로세스가 다음에 실행할 명령어의 주소를 가리킨다
  * 문맥 교환 시 이 값을 저장하고 복원하여 프로세스가 이전 상태에서 이어서 실행될 수 있도록 한다

* **CPU 레지스터(CPU registers)**
  * 프로세스가 실행 중일 때 사용하던 모든 CPU 레지스터의 값
  * 문맥 교환 시 이 값을 저장하고 복원하여 프로세스의 연속성을 보장한다

* **CPU 스케쥴링 정보(CPU scheduling information)**
  * 프로세스의 우선순위, 스케줄링 큐 포인터, 기타 스케줄링 매개변수 등의 정보를 포함한다
  * 스케줄러가 프로세스를 효율적으로 관리하기 위해 사용한다

* **메모리 관리 정보(Memory management information)**
  * 프로세스의 메모리 공간에 대한 정보를 포함한다
  * 프로세스 마다 사용하는 메모리 주소가 다르니깐 당연히 메모리 주소에 대한 정보가 필요하다
  * 예를 들어, 페이지 테이블(page table), 세그먼트 테이블, 베이스 및 리미트 레지스터 등의 정보가 포함된다

* **집계 정보(Accounting information)**
  * CPU 사용 시간, 실제 사용 시간, 프로세스 생성 시간 등과 같은 정보를 포함한다
  * 주로 성능 분석과 자원 할당 최적화에 사용된다

* **입출력 상태 정보(I/O status information)**
  * 프로세스가 사용 중인 입출력 장치와 파일에 대한 정보를 포함한다
  * 예를 들어, 열린 파일 목록, 입출력 장치 큐 등의 정보가 포함된다


<br>

---

### 문맥 교환(Context Switch)

> **타임 슬라이스(Time Slice)**
>
> **각 프로세스가 CPU를 사용할 수 있는 최대 시간**. 이 시간 동안 프로세스는 실행 상태를 유지하며, 타임 슬라이스가 끝나면 운영 체제는 다른 프로세스에 CPU를 할당한다.
{: .prompt-info }

<br>

> **타이머 인터럽트 (Timer Interrupt)**
>
> 타이머 하드웨어에 의해 설정된 주기적인 인터럽트. 이 인터럽트는 CPU 시간을 추적하고 타임 슬라이스가 종료되었음을 운영 체제에 알리는 역할을 한다.
{: .prompt-info }

<br>

**프로세스들은 번갈아가며 한정된 시간 만큼만 CPU를 이용**한다고 설명했다. 프로세스들은 타임 슬라이스(time slice)라는 일정한 시간 간격을 사용하여 각 프로세스에 CPU를 사용할 수 있는 시간을 할당하고, 각 타임 슬라이스가 끝날 때마다 타이머 인터럽트(timer interrupt)가 발생해서 해당 타임 슬라이스가 만료되었음을 알린다. 이후 프로세스가 전환된다.

여기서 **컨텍스트 스위치(context switch)는 운영 체제가 CPU를 하나의 프로세스에서 다른 프로세스로 전환하는 과정**이다.

<br>

![context-switch](../post_images/2023-08-02-os-02-process/context-switch.png)_context switch_

<br>

컨텍스트 스위치의 대략적인 과정은 다음과 같다.

* **현재 프로세스 상태 저장**
  * 타이머 인터럽트가 발생하면, 운영 체제는 **현재 실행 중인 프로세스의 상태 정보를 PCB에 저장**한다
  * 이 정보에는 CPU 레지스터, 프로그램 카운터, 메모리 관리 정보 등이 포함된다
* **스케줄러 호출**
  * **운영 체제의 스케줄러가 호출되어 다음에 실행될 프로세스를 결정**한다
  * 스케줄러는 준비 상태 큐(ready state queue)에 있는 프로세스 중에서 선택한다
* **새 프로세스 상태 로드(복원)**
  * 선택된 프로세스의 PCB에서 상태 정보를 참조해서 상태를 복원한다
  * 이 정보에는 해당 프로세스가 마지막으로 실행되었을 때의 CPU 레지스터 값, 프로그램 카운터, 메모리 관리 정보 등이 포함된다
* **프로세스 전환**
  * CPU가 새 프로세스를 실행하기 시작한다
  * 프로그램 카운터의 값을 새 프로세스의 시작 지점으로 설정하고, CPU 레지스터 값을 새 프로세스의 값으로 설정한다

<br>

> **프로세스의 상태 정보를 문맥(context)**이라고 한다. 그래서 프로세스의 교환을 이런 문맥을 교환한다고 해서 문맥 교환(context switching)이라고 부른다.
{: .prompt-info }

<br>

이런 컨텍스트 스위칭을 통해서 여러 프로세스가 동시에 실행되는 것처럼 보여지는 멀티태스킹(multi-tasking)을 구현할 수 있고, 시스템 자원의 분배와 CPU 활용을 극대화할 수 있다.

컨텍스트 스위치는 필수적인 작업이지만, **비용이 발생한다**. 이러한 비용을 **오버헤드(Overhead)**라고 표현한다. 오버헤드에 해당하는 요소는 다음과 같다.

* **저장 및 로드 시간**: 현재 프로세스의 상태를 저장하고, 새 프로세스의 상태를 로드하는 시간
* **캐시 손실**: 컨텍스트 스위치가 발생하면 CPU 캐시가 비워지거나 재배치되어야 하는 경우가 있다
* **메모리 관리 작업**: 프로세스의 메모리 맵이 변경되면, TLB(Translation Lookaside Buffer)와 같은 메모리 관리 구조가 무효화될 수 있다(가상 메모리에서 다룰 예정이다)

<br>

이런 컨텍스트 스위치의 오버헤드를 줄이는 방법에 대해서는 이후에 스레드(thread)를 다루고나서 살펴볼 것이다.

<br>

---

### 프로세스 계층 구조(Process Hierarchy)

프로세스의 계층 구조는 **운영 체제에서 프로세스들이 어떻게 계층적으로 조직되고 관리되는지를 설명하는 개념**이다. 이 구조는 다양한 프로세스들이 서로 관계를 맺고 협력하며 실행되는 방식을 이해하는 데 중요하다.

프로세스는 실행 도중에 시스템 콜을 통해서 다른 프로세스를 생성할 수 있다.

* 새 프로세스를 생성한 프로세스: **부모 프로세스(Parent process)**
* 부모 프로세스에 의해 생성된 프로세스: **자식 프로세스(Child process)**
* 자식 프로세스는 또 다른 자식 프로세스를 생성할 수 있다

<br>

다음 그림은 **프로세스 트리(Process Tree)**이다.

<br>

![p-hierarchy](../post_images/2023-08-02-os-02-process/p-hierarchy.png)_process tree_

* 프로세스 계층 구조는 **프로세스 트리**로 시각화될 수 있다
* 이 트리는 루트 프로세스(root process)에서 시작하여 자식 프로세스들로 확장된다
* 부모 프로세스와 자식 프로세스는 별개의 PID를 가진다
  * 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스의 PID(PPID)를 명시하기도 한다


<br>

> **루트 프로세스(Root Process)**
>
> 시스템이 시작될 때 가장 먼저 실행되는 프로세스. 루트 프로세스 이외의 모든 프로세스는 이 프로세스에서 파생된다. 현대 Linux 시스템에서는 `systemd`가 루트 프로세스를 담당하고 있다. (`pid`가 `1`인 프로세스)
>
> `systemd`는 기존에 사용되던 `init`을 대체하면서 기능과 성능 향상이 이루어졌다.
>
> `systemd` [참고](https://docs.redhat.com/ko/documentation/red_hat_enterprise_linux/7/html/system_administrators_guide/chap-managing_services_with_systemd)
{: .prompt-info }

<br>

---

### 프로세스의 생성: fork(), exec()

프로세스 생성에 사용되는 `fork()`와 `fork()-exec()` 기법을 살펴보자.















## Reference

1. [강민청: 혼자 공부하는 컴퓨터 구조 + 운영체제](https://product.kyobobook.co.kr/detail/S000061584886)
2. [Abraham Silberschatz: Operating System Concepts(공룡책)](https://product.kyobobook.co.kr/detail/S000003114660)
3. [쉬운코드: 운영체제](https://www.youtube.com/watch?v=QmtYKZC0lMU&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-)