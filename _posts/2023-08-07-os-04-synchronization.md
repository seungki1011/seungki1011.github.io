---
title: (OS - 4) 동기화(Synchronization)
description: 동기화 소개, 동기화와 관련된 문제들, 여러 동기화 기법들에 대하여
author: seungki1011
date: 2023-08-05 12:30:00 +0900
categories: [1. 컴퓨터 공학(CS), 컴퓨터 구조/운영체제(OS)]
tags: [os, synchronization, mutex, semaphore, moniter]
math: true
mermaid: true
---

---

## 1. 동기화(Synchronization)

### 동기화 소개

**동기화(Synchronization)**는 여러 프로세스나 스레드가 **동시에 실행될 때, 이들의 실행 순서를 제어하여 일관성 있는 결과를 보장하는 기술**이다. 동기화는 **주로 공유 자원에 대한 접근을 제어하여 데이터 무결성을 유지하고, 교착 상태(Deadlock)와 경쟁 조건(Race Condition)을 방지**하는 데 사용된다.

<br>

> **데이터 무결성(Data Integerity)**
>
> 데이터의 정확성, 일관성, 유효성이 유지되는 것.
{: .prompt-info }


<br>

> 이 포스트에서 프로세스와 스레드를 통틀어서 **작업(task)**이라는 표현을 사용할 것이다.
{: .prompt-warning }

<br>

다시 정리하자면 동기화가 필요한 주된 이유는 **공유 자원**에 대한 **동시 접근**으로 인한 **데이터 일관성 문제**를 해결하기 위함이다.

* **경쟁 조건(Race Condition):** 여러 스레드가 동시에 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라질 수 있는 상황이 올 수 있다
* **데이터 일관성(Data Consistency):** 여러 스레드가 공유 데이터를 일관되게 읽고 쓸 수 있도록 보장해야 한다
* **교착 상태(Deadlock):** 두 개 이상의 스레드가 서로가 가지고 있는 자원을 기다리느라 무한 대기 상태에 빠지는 상황이 올 수 있다

<br>

동기화는 보통 이 문제들을 해결하기 위해서 다음을 보장하도록 해야한다.

* **실행 순서 제어(execution order control)**: 작업이 올바른 순서로 실행되도록 한다
* **상호 배제(mutual exclusion)**: 동시에 접근해서는 안되는 자원에 하나의 작업만 접근하도록 한다
* 더 자세한 내용은 뒤에서 다룬다

<br>

---

### 임계 구역(Critical Section)

**공유 자원(Shared Resource)은 여러 작업이 동시에 접근하고 사용할 수 있는 자원**을 의미한다. 동시에 접근할 수 있는 변수, 파일, 데이터 구조, 입출력 장치, 등을 전부 공유 자원이라고 할 수 있다.

이런 **공유 자원에 접근하는 코드의 영역을 임계 구역(Critical Section)**이라고 한다. 임계 구역에서는 기본적으로 하나의 작업만 실행되도록 해야 한다.

이런 **임계 구역을 통해 동시에 공유 자원에 접근해서 발생하는 문제를 Race Condition**이라고 한다.

<br>

> **Race Condition**
>
> 여러 작업이 동시에 공유 자원에 접근할 때, 접근 순서나 타이밍에 따라 프로그램의 결과가 달라지는 상황을 말한다. 이러한 상황은 **데이터 일관성 문제**를 일으키며, 예기치 않은 버그나 시스템 오류를 발생시킬 수 있다.
>
> 자원을 가지고 경쟁 한다고 해서 경합(Race)이라는 표현이 사용된다.
{: .prompt-info }

<br>

레이스 컨디션(Race Condition)이 발생하는 **근본적인 이유 중 하나는 고수준(high-level) 언어에서 작성된 코드가 저수준(low-level)에서 실행될 때 예상치 못한 방식으로 인터리빙(섞여서) 실행될 수 있기 때문**이다.

고수준 코드에서 `counter`를 증가시키는 단순한 작업을 한번 살펴보자.

```cpp
int counter = 0;

void increment() {
    counter++;
}
```

* 해당 코드는 단순히 `counter`의 값을 `1` 증가시키는 코드이다
* 나중에 `increment()`를 사용했을때, `counter`를 증가시키는 부분이 임계구역이 된다

<br>

그럼 해당 코드의 저수준(어셈블리)에서의 동작을 살펴보자.

```assembly
mov eax, [counter]  ; counter의 값을 메모리에서 레지스터로 읽어온다
add eax, 1  ; 레지스터의 값을 증가시킨다
mov [counter], eax  ; 증가된 값을 다시 메모리에 쓴다
```

* 고수준에서의 `counter++` 연산은 저수준에서는 여러 단계로 나뉘어 수행된다
  * `counter`의 값을 메모리에서 레지스터로 읽어온다
  * 레지스터의 값을 증가시킨다
  * 증가된 값을 다시 메모리에 쓴다

<br>

이 코드에서 **레이스 컨디션이 발생하는 상황**을 살펴보자. 두 개의 스레드가 동시에 `increment()` 함수를 호출한다고 가정해보자.

![interleaving](../post_images/2023-08-07-os-04-synchronization/interleaving.png)_Race Condition_

* 임계 구역은 동시에 접근하는 `counter`를 증가시키는 영역이다
* `스레드A`와 `스레드B`가 동시에 `counter`에 접근하고, 자기의 레지스터에 저장하고 값을 증가 시키는 일련의 과정에서 코드가 인터리빙(섞일) 될 수 있다
* 결론적으로 `스레드A`에서 한번 증가시키고, `스레드B`에서 한번 증가시켜서 `2`라는 값이 나오길 기대하지만, 실제 결과는 `1`이 나올 수 있다

<br>

표로 레이스 컨디션이 일어나는 과정을 살펴보자.

![race1](../post_images/2023-08-07-os-04-synchronization/race1.png)_Race Condition_

<br>

> **컨텍스트 스위치를 막으면 레이스 컨디션을 해결할 수 있을까?**
>
> 결론부터 말하자면 불가능하다. 왜냐하면 멀티코어 환경에서는 스레드가 병렬로 처리될 수 있기 때문이다.
{: .prompt-info }

<br>

그러면 운영체제는 이런 **임계 구역 문제를 어떻게 해결**할까? 

일단 코드의 기본적인 모양새는 다음과 같이 구현한다.

![critical1](../post_images/2023-08-07-os-04-synchronization/critical1.png)_Critical Section_

* **입장 구역(Entry Section)**
  * 이 구역에서는 스레드가 임계 구역에 진입하기 전에 필요한 동기화 작업을 수행한다
  * 특정 스레드가 이미 임계 구역에 들어가 있을 때 다른 스레드의 진입을 기다리게 한다
* **퇴장 구역(Exit Section)**
  * 이 구역에서는 스레드가 임계 구역에서 나올 때 필요한 동기화 작업을 수행한다
  * 임계 구역에 대한 접근 권한을 해제하여 다른 스레드가 임계 구역에 진입할 수 있도록 한다

<br>

위의 코드는 기본적인 뼈대이고, **실제로 임계 구역 문제를 해결하기 위해서는 다음의 3 가지 조건을 만족**하도록 구현해야 한다.

1. **상호 배제(Mutual Exclusion)**
   * **동시에 하나의 프로세스나 스레드만 임계 구역에 접근할 수 있어야 한다**. 쉽게 말해서 동시에 2 개 이상의 작업이 임계 구역에 진입해선 안된다.
   * 임계 구역에 대한 접근을 독점적으로 관리하여 데이터 무결성을 유지한다
2. **진행 조건(Progress Condition)**
   * **임계 구역에 접근하려는 프로세스가 없을 때, 다른 프로세스가 대기 중이라면 그 프로세스는 임계 구역에 접근할 기회를 가져야 한다**
   * **데드락(Dead-lock) 방지**: 이는 대기 중인 프로세스가 계속해서 임계 구역에 접근하지 못하는 상황을 방지한다
3. **한정 대기(Bounded Waiting)**
   * **특정 프로세스가 임계 구역에 접근하기 위해 무한정 대기하지 않도록 보장해야 한다**. 쉽게 말해서 특정 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 진입할 수 있어야 한다.
   * **기아(Starvation) 방지**: 특정 프로세스가 무한정 대기하는 것을 방지한다
   * 대기 시간에 대한 상한을 설정하여 공정성을 보장한다

<br>

이제 운영체제가 이런 원칙을 이루기 위해서 사용하는 동기화 기법들을 살펴보자.

<br>

---

## 2. 동기화 기법

### 뮤텍스(Mutex)

일단 **상호 배제(Mutual Exclusion)을 보장하기 위해서 사용하는 가장 기본적인 방법은 락(Lock)을 사용**하는 것이다.

<br>

![lock](../post_images/2023-08-07-os-04-synchronization/lock.png)_Lock_

* 프로세스가 임계구역에 진입하기 위해서는 락을 얻어야 한다
* 프로세스가 임계구역에서 퇴장할때 락을 반환한다

<br>

`acquire()`과 `release()`의 대략적인 구현은 아래와 같다. 원자적(atomic)으로 수행되어야 한다.

<br>

![mutexlock](../post_images/2023-08-07-os-04-synchronization/mutexlock.png)_acquire and release_

<br>



<br>

> **Test-and-Set, Compare-and-Swap(CAS)**
>
> 뮤텍스, 스핀락, 세마포어 등의 동기화 기법은 기본적으로 하드웨어 수준에서 제공하는 원자성(atomicity)을 보장하는 연산을 사용해서 구현한다.
>
> 제공하는 연산으로는 **Test-and-Set**, **Compare-and-Swap(CAS)**, 등이 있다.
>
> ![testandset](../post_images/2023-08-07-os-04-synchronization/testandset.png)_Test and Set_
>
> * 특정 플래그 변수(보통 boolean 타입)를 원자적으로 읽고, 동시에 해당 플래그를 설정한다
> * 다음의 두 가지 작업을 동시에 수행한다
>   * **읽기:** 현재 플래그 변수(`*target`)의 값을 읽어온다
>   * **설정:** 플래그 변수를 `true`로 설정한다
>
> <br>
>
> ![compareandswap](../post_images/2023-08-07-os-04-synchronization/compareandswap.png)_Compare and Swap_
>
> * 특정 메모리 위치의 값이 예상한 값과 일치할 때만 새로운 값으로 교체한다
> * **기대 값(`expected`):** 현재 메모리 위치에 저장된 값과 비교할 값
> * **새 값 (`new_value`):** 메모리 위치를 업데이트할 새로운 값
> * **메모리 위치 (`value`):** 업데이트할 실제 메모리 위치
> * 다음의 연산을 수행한다
>   * 메모리 위치의 현재 값이 기대 값과 같으면, 새로운 값으로 교체한다
>   * 그렇지 않으면, 메모리 위치의 현재 값이 기대 값으로 업데이트된다
> * CAS는 스핀락, 원자적 데이터 구조 구현 등에 사용된다
{: .prompt-info }

<br>





























## 5. 동기화 문제들

동기화와 프로세스 간 통신에 관련된 대표적인 문제 시나리오들을 살펴보자.

<br>

### Reader-Writer Problem

이 문제는 여러 작업이 공유 자원에 접근할 때 읽기와 쓰기 작업이 어떻게 조정되어야 하는지에 대해서 다룬다.

기본적으로 다음과 같은 상황을 고려한다.

* **읽기 작업 (Read):** 여러 `reader`가 동시에 공유 자원을 읽을 수 있다. 읽기는 **자원을 변경하지 않기 때문에 동시에 여러 작업이 읽어도 문제되지 않는다**
* **쓰기 작업 (Write):** 공유 자원을 **쓰는 작업은 자원을 변경하므로 동시에 하나의 작업만 접근**할 수 있어야 한다. 동시에 두 개 이상의 작업이 쓰기를 시도하면 데이터 무결성에 문제가 발생할 수 있다.
* **혼합 작업 (Read/Write):** 읽기와 쓰기가 동시에 일어나는 경우, 읽기 작업과 쓰기 작업은 서로 충돌하지 않아야 하며, **쓰기 작업이 진행되는 동안에는 다른 읽기 작업이나 쓰기 작업이 들어와서는 안된다**

<br>

Reader-Writer 문제는 보통 두 가지 유형으로 나뉜다.

1. 여러 `reader`가 동시에 읽을 수 있지만, `writer`가 한 번에 하나만 접근할 수 있어야 하는 문제
   * 이 경우, `writer`가 자원에 접근하고 있을 때는 다른 `reader`(또는 `writer`)도 접근할 수 없도록 해야 한다
2. `reader`와 `writer` 간의 우선 순위 문제
   * 예를 들면, `writer`가 기다리는 동안 `reader`가 계속 접근하게 되면, `writer`가 무한히 대기하게 되는 문제가 발생할 수 있다. 이 문제를 해결하기 위해 우선순위 정책을 추가해야 한다.

<br>

문제를 해결하기 위해서 다음과 같은 방법을 사용한다.

* 읽기 우선(Reader-Preferred)
  * 읽기 작업이 우선되며, `writer`가 대기 중이라도 읽기 작업은 계속 진행된다
  * 단, `writer`가 진행 중이면 읽기가 차단된다
* 쓰기 우선(Writer-Preferred)
  * 쓰기 작업이 우선되며, `writer`가 대기 중일 때 읽기 작업도 차단된다
  * 읽기 작업이 진행 중일 때 쓰기 작업이 대기하게 된다





























---

## Reference

1. [https://velog.io/@gabie0208/OS-Interleaving-Race-condition-Critical-Section](https://velog.io/@gabie0208/OS-Interleaving-Race-condition-Critical-Section)
